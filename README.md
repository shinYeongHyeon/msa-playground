# MSA-Playground

이 저장소는 **마이크로 서비스 패턴** 책을 읽고 작성하는 곳이다. 

---

## Food To Go (FTGO)

2005년 후반 설립된 미국 온라인 음식 배달 회사  
자바/ 하나의 WAR 파일로 구성된 모놀리스 개발,

### FTGO Application Architecture

![](src/FTGO_%20Monolithic_Architecture.jpg)

논리적으로는 모듈화한 아키텍쳐임에도 애플리케이션은 WAR 하나로 패키징  
그렇다면 모놀리식은 나쁜 건가 ?

#### 모놀리식 아키텍쳐의 장점
모놀리식이 나쁜 건 아니다, 충분히 좋다.

1. **개발이 간단하다** : IDE 등 개발 툴 들은 단일 애플리케이션 구축에 초점이 맞추어져 있다.
2. **애플리케이션 변경이 쉽다** : 코드, DB 스키마 등을 하나만 변경해서 빌드/배포하기 용이하다.
3. **테스트가 용이하다** : 어플리케이션을 띄우고, API 호출하고, UI 테스트 하며, 종단 간 테스트를 하면 된다.  
4. **배포가 쉽다** : 한 곳에서만 올리면 된다.  
5. **확장이 쉽다** : 애플리케이션 인스턴스를 여러 개 실행하면 된다.

그런데, 시나브로 개발/테스트/배포/확장은 소모성 회의는 많아지고, 애자일 방법론도 도입해보았지만 개발 속도는 점점 더 더뎌진다.

### WHY ?

#### 1. 모놀리식의 근본적 한계

스프린트를 진행해 나갈수록 추가 구현할 스토리가 늘어갔고, 그만큼 코드베이스와 관리 오버헤드는 점점 더 증가.  
점점 더 인원은 늘어나겠죠.  

한 때는 조그마했던 어플리케이션은 수년간 계속 몸집이 커지고, 거대하게 바뀌었고 소규모였던 개발 팀도 이제는 거대해지고 분야가 나뉘어진다.  
아키텍처가 몸에 맞지 않게 되니 FTGO 는 모놀리식 지옥에 빠져 지금은 애자일식 개발/배포도 어려워짐.  
왜 그럴까 ?

##### 2. 너무 복잡해서 개발자가 주눅든다.

거대해진 모놀리식 애플리케이션은 일단 **너무 복잡**하다.  
여느 개발자가 완전히 이해할 수 없을 정도로 내용이 방대해서 버그를 고치는 것조차 어려워지고, 새 기능을 정확하게 구현하기가 갈수록 힘들고 시간도 오래 걸린다.  
마감일자 놓치기는 덤.  
개발하면서, 변경이 될 때마다 코드베이스는 한층 더복잡해지고 난해한 코드로 뒤덮이게 된다.  

##### 3. 개발이 더디다

복잡도와 싸우는 것과는 별개로 개발자의 일상마저 더뎌지게 된다.  
애플리케이션이 너무 거대해 IDE 속도는 느려지고, 빌드 시간도 오래걸리게 된다.  
코드를 수정하고 빌드/실행 후 테스트까지 너무 많은 시간이 소요된다.  

##### 4. 커밋부터 배포에 이르는 길고 험난한 여정  

고친 내용을 실서버/프로덕션에 배포하는 일이 아주 길고 고통스러워진다.  
여러 코드가 한 곳에 몰리다 보니 테스트도 어려워 지고 릴리스 자체가 어려워 지기도 하죠.  
**feature branch** 로 이 문제가 해결되나 싶었지만 결국 고통스러운 **rebase/merge** 작업이 새로 나오게 되었죠.  

##### 5. 확장하기 어렵다.

##### 6. 확실한 전달이 어렵다

애플리케이션 자체가 너무 크다보니 철저하게 테스트하기가 어려워지고, 이로 인해 버그 발생률이 올라가며, 신뢰성이 떨어지게 된다.  
전체 모듈이 하나의 프로세스로 실행되는 까닭에 결함이 서로 격리 (Fault Isolation) 되지 않고 그러다 보니 버그가 하나만 있어도 전체 애플리케이션에 영향을 주는 케이스가 생기죠.  
이거는 매출고 직결되어 경영진의 신뢰도와도 연결되죠.  

##### 7. 갈수록 한물간 기술 스택에 발목이 붙잡히다.  

끝으로, 모놀리식 지옥은 거대하고 고착화된 아키텍쳐로 인해서 점점 한물간 기술스택이 되어진다.  
**"특성상", "이렇다보니", "어쩔 수 없이", "일단은", "무서우니까"** 
규모가 큰 팀이면, 커지는 팀이라면 여러 사람이 모놀리식 애플리케이션 하나에 달라붙어 작업할 때 일어나는 어쩔 수 없는 일들이다.  
팀 차원에서 필연적으로 일어날 일들을 조금 늦추는 일 외에는 방법이 없다.  
이 지옥을 탈출하는 방법은 마이크로서비스 아키텍쳐의 문을 여는 방법밖에 없다.  

### 확장 큐브와 마이크로 서비스

**확장 큐브**
![](./src/3차원_확장큐브.jpg)

#### X축 확장 : 다중 인스턴스에 고루 요청 분산

일반적인 모놀리식 애플리케이션의 확장 수단  
부하 분산기를 두고 부하 분산기 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 들어온 요청을 이들 인스턴스에 고루 분배한다.  
애플리케이션 능력과 가용성을 개선할 수 있는 훌륭한 방법

![](./src/부하분산.png)  

#### Z축 확장 : 요청 속성별 라우팅

인스턴스별로 주어진 데이터 하위집합 (subset) 만 처리하도록 설정하는 방법.  
인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅 (e.g. UserId 에 따라)  

![](./src/라우팅.png)

그림에서 인스턴스는 자신에게 배정된 사용자 하위 집합만 처리한다.  
라우터는 요청 헤더 *Authorization* 에 포함된 *userId* 를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택.  
Z 축 확장은 애플리케이션을 확장해서 중가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단  

#### Y축 확장 : 기능에 따라 어플리케이션을 서비스로 분해  

X축/Z축 확장을 하면 애플리케이션 능력 및 가용성은 개선되나, 애플리케이션이 점점 복잡해지는 문제는 해결되지 않는다.  
따라서, 기능분해가 필요하다.  
모놀리식 애플리케이션을 여러 **서비스**로 쪼개는 것이다.  

![](./src/기능분해.png)

서비스는 주문관리, 고객관리, 리뷰등 지엽적 기능이 구현된 미니 애플리케이션이다.  

마이크로 서비스 아키텍쳐는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능분해하는 아키텍쳐 스타일이다.  
여기서 중요한 것은 **크기**가 아니라, 각 서비스가 **집중된(focused) / 응집된 (cohesive) 책임**을 맡고 있다는 사실이다. 

### 모듈성

크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성  
최근 애플리케이션은 규모가 방대하고, 복잡하여 어느 한 개인이 전부 다 이해하고 개발할 수 없음  
고로, 여러 사람이 이해할 수 있어야 하고, 개발할 수 있게 애플리케이션을 모듈로 분해하여야 한다.  
마이크로 서비스 아키텍처는 서비스를 **모듈성의 단위**로 사용  
각 서비스는 다른 서비스가 함부로 규칙을 어기거나 침투하거나, 내부를 알 필요없게 API 라는 경계선을 지니고 있어, 다른 서비스 API를 위회하여 그 내부 클래스에 마음대로 들어올 수 없게 한다.  
따라서, 시간이 지나도 애플리케이션 모듈성을 유지하기가 훨씬 수월해지고, 서비스를 빌딩 블록 처럼 사용해 독립적으로 배포/확장 할 수 있는 부가적 장점도 있음.  

### 서비스 마다 DB 를 따로

마이크로 서비스는 서로 굉장히 **느슨하게** 연결되어 있고, 오직 API 를 통해서만 통신한다.  
느슨하게 연결돼있다 함은, 식당에서 요리를 주문하는 것과 같음.  
그저 주문만 하면 되지, 요리가 어떻게 만들어지는지, 어떤 재료를 가지고 있는지는 알 필요가 없다.  
같은 업계의 다른 요리사가 오더라도,  
이 말을 서비스로 다시 돌아와 얘기하면, 요리/재료 들은 ? DB 가 된다.  
각각 자체 DB를 갖고 있어서, 주문하는 고객이, 즉, 다른 모듈이 사용하려는 모듈과 일일이 협의 하지 않고 모듈 자신만의 스키마를 가지고, 변경할 수 있다.  
이로 인해 다른 서비스가 DB Lock 을 획득해서 내 서비스를 블로킹하는 일이 존재하지 않음.

- [ ] 그렇다면 RDBMS 구매 비용이 서비스(모듈) 갯수만큼 늘어나 ? 2장에서 확인

### FTGO Microservice Architecture

#### Y축 확장의 결과
- 주문서비스 : 주문을 관리
- 배달 서비스 : 음식점에서 소비자에 이르기까지 주문 배달을 관리
- 음식점 서비스 : 음식점 관련 정보를 관리  
- 주방 서비스 : 주문한 음식을 준비하는 과정을 관리
- 화계 서비스 : 과금/지불을 관리  

![](./src/FTGO_MSA.png)

서비스와 API 가 분명하게 분리돼 정의된 것만 다를 뿐, 앞선 모놀리식과 정확하게 대응 된다.  
각 서비스를 **독립적으로** 개발, 테스트, 배포, 확장가능하며 개발자가 타 서비스의 API 를 우회하거나 그 내부요소에 직접 접근할 수 없어 모듈성 유지 차원에서도 적합
