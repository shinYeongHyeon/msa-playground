# MSA-Playground

이 저장소는 **마이크로 서비스 패턴** 책을 읽고 작성하는 곳이다. 

---

## Food To Go (FTGO)

2005년 후반 설립된 미국 온라인 음식 배달 회사  
자바/ 하나의 WAR 파일로 구성된 모놀리스 개발,

### FTGO Application Architecture

![](src/FTGO_%20Monolithic_Architecture.jpg)

논리적으로는 모듈화한 아키텍쳐임에도 애플리케이션은 WAR 하나로 패키징  
그렇다면 모놀리식은 나쁜 건가 ?

#### 모놀리식 아키텍쳐의 장점
모놀리식이 나쁜 건 아니다, 충분히 좋다.

1. **개발이 간단하다** : IDE 등 개발 툴 들은 단일 애플리케이션 구축에 초점이 맞추어져 있다.
2. **애플리케이션 변경이 쉽다** : 코드, DB 스키마 등을 하나만 변경해서 빌드/배포하기 용이하다.
3. **테스트가 용이하다** : 어플리케이션을 띄우고, API 호출하고, UI 테스트 하며, 종단 간 테스트를 하면 된다.  
4. **배포가 쉽다** : 한 곳에서만 올리면 된다.  
5. **확장이 쉽다** : 애플리케이션 인스턴스를 여러 개 실행하면 된다.

그런데, 시나브로 개발/테스트/배포/확장은 소모성 회의는 많아지고, 애자일 방법론도 도입해보았지만 개발 속도는 점점 더 더뎌진다.

### WHY ?

#### 1. 모놀리식의 근본적 한계

스프린트를 진행해 나갈수록 추가 구현할 스토리가 늘어갔고, 그만큼 코드베이스와 관리 오버헤드는 점점 더 증가.  
점점 더 인원은 늘어나겠죠.  

한 때는 조그마했던 어플리케이션은 수년간 계속 몸집이 커지고, 거대하게 바뀌었고 소규모였던 개발 팀도 이제는 거대해지고 분야가 나뉘어진다.  
아키텍처가 몸에 맞지 않게 되니 FTGO 는 모놀리식 지옥에 빠져 지금은 애자일식 개발/배포도 어려워짐.  
왜 그럴까 ?

##### 2. 너무 복잡해서 개발자가 주눅든다.

거대해진 모놀리식 애플리케이션은 일단 **너무 복잡**하다.  
여느 개발자가 완전히 이해할 수 없을 정도로 내용이 방대해서 버그를 고치는 것조차 어려워지고, 새 기능을 정확하게 구현하기가 갈수록 힘들고 시간도 오래 걸린다.  
마감일자 놓치기는 덤.  
개발하면서, 변경이 될 때마다 코드베이스는 한층 더복잡해지고 난해한 코드로 뒤덮이게 된다.  

##### 3. 개발이 더디다

복잡도와 싸우는 것과는 별개로 개발자의 일상마저 더뎌지게 된다.  
애플리케이션이 너무 거대해 IDE 속도는 느려지고, 빌드 시간도 오래걸리게 된다.  
코드를 수정하고 빌드/실행 후 테스트까지 너무 많은 시간이 소요된다.  

##### 4. 커밋부터 배포에 이르는 길고 험난한 여정  

고친 내용을 실서버/프로덕션에 배포하는 일이 아주 길고 고통스러워진다.  
여러 코드가 한 곳에 몰리다 보니 테스트도 어려워 지고 릴리스 자체가 어려워 지기도 하죠.  
**feature branch** 로 이 문제가 해결되나 싶었지만 결국 고통스러운 **rebase/merge** 작업이 새로 나오게 되었죠.  

##### 5. 확장하기 어렵다.

##### 6. 확실한 전달이 어렵다

애플리케이션 자체가 너무 크다보니 철저하게 테스트하기가 어려워지고, 이로 인해 버그 발생률이 올라가며, 신뢰성이 떨어지게 된다.  
전체 모듈이 하나의 프로세스로 실행되는 까닭에 결함이 서로 격리 (Fault Isolation) 되지 않고 그러다 보니 버그가 하나만 있어도 전체 애플리케이션에 영향을 주는 케이스가 생기죠.  
이거는 매출고 직결되어 경영진의 신뢰도와도 연결되죠.  

##### 7. 갈수록 한물간 기술 스택에 발목이 붙잡히다.  

끝으로, 모놀리식 지옥은 거대하고 고착화된 아키텍쳐로 인해서 점점 한물간 기술스택이 되어진다.  
**"특성상", "이렇다보니", "어쩔 수 없이", "일단은", "무서우니까"** 
규모가 큰 팀이면, 커지는 팀이라면 여러 사람이 모놀리식 애플리케이션 하나에 달라붙어 작업할 때 일어나는 어쩔 수 없는 일들이다.  
팀 차원에서 필연적으로 일어날 일들을 조금 늦추는 일 외에는 방법이 없다.  
이 지옥을 탈출하는 방법은 마이크로서비스 아키텍쳐의 문을 여는 방법밖에 없다.  

### 확장 큐브와 마이크로 서비스

**확장 큐브**
![](./src/3차원_확장큐브.jpg)

#### X축 확장 : 다중 인스턴스에 고루 요청 분산

일반적인 모놀리식 애플리케이션의 확장 수단  
부하 분산기를 두고 부하 분산기 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 들어온 요청을 이들 인스턴스에 고루 분배한다.  
애플리케이션 능력과 가용성을 개선할 수 있는 훌륭한 방법

![](./src/부하분산.png)  

#### Z축 확장 : 요청 속성별 라우팅

인스턴스별로 주어진 데이터 하위집합 (subset) 만 처리하도록 설정하는 방법.  
인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅 (e.g. UserId 에 따라)  

![](./src/라우팅.png)

그림에서 인스턴스는 자신에게 배정된 사용자 하위 집합만 처리한다.  
라우터는 요청 헤더 *Authorization* 에 포함된 *userId* 를 보고 N개의 동일한 애플리케이션 인스턴스 중 하나를 선택.  
Z 축 확장은 애플리케이션을 확장해서 중가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단  

#### Y축 확장 : 기능에 따라 어플리케이션을 서비스로 분해  

X축/Z축 확장을 하면 애플리케이션 능력 및 가용성은 개선되나, 애플리케이션이 점점 복잡해지는 문제는 해결되지 않는다.  
따라서, 기능분해가 필요하다.  
모놀리식 애플리케이션을 여러 **서비스**로 쪼개는 것이다.  

![](./src/기능분해.png)

서비스는 주문관리, 고객관리, 리뷰등 지엽적 기능이 구현된 미니 애플리케이션이다.  

마이크로 서비스 아키텍쳐는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능분해하는 아키텍쳐 스타일이다.  
여기서 중요한 것은 **크기**가 아니라, 각 서비스가 **집중된(focused) / 응집된 (cohesive) 책임**을 맡고 있다는 사실이다. 

### 모듈성

크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성  
최근 애플리케이션은 규모가 방대하고, 복잡하여 어느 한 개인이 전부 다 이해하고 개발할 수 없음  
고로, 여러 사람이 이해할 수 있어야 하고, 개발할 수 있게 애플리케이션을 모듈로 분해하여야 한다.  
마이크로 서비스 아키텍처는 서비스를 **모듈성의 단위**로 사용  
각 서비스는 다른 서비스가 함부로 규칙을 어기거나 침투하거나, 내부를 알 필요없게 API 라는 경계선을 지니고 있어, 다른 서비스 API를 위회하여 그 내부 클래스에 마음대로 들어올 수 없게 한다.  
따라서, 시간이 지나도 애플리케이션 모듈성을 유지하기가 훨씬 수월해지고, 서비스를 빌딩 블록 처럼 사용해 독립적으로 배포/확장 할 수 있는 부가적 장점도 있음.  

### 서비스 마다 DB 를 따로

마이크로 서비스는 서로 굉장히 **느슨하게** 연결되어 있고, 오직 API 를 통해서만 통신한다.  
느슨하게 연결돼있다 함은, 식당에서 요리를 주문하는 것과 같음.  
그저 주문만 하면 되지, 요리가 어떻게 만들어지는지, 어떤 재료를 가지고 있는지는 알 필요가 없다.  
같은 업계의 다른 요리사가 오더라도,  
이 말을 서비스로 다시 돌아와 얘기하면, 요리/재료 들은 ? DB 가 된다.  
각각 자체 DB를 갖고 있어서, 주문하는 고객이, 즉, 다른 모듈이 사용하려는 모듈과 일일이 협의 하지 않고 모듈 자신만의 스키마를 가지고, 변경할 수 있다.  
이로 인해 다른 서비스가 DB Lock 을 획득해서 내 서비스를 블로킹하는 일이 존재하지 않음.

- [ ] 그렇다면 RDBMS 구매 비용이 서비스(모듈) 갯수만큼 늘어나 ? 2장에서 확인

### FTGO Microservice Architecture

#### Y축 확장의 결과
- 주문서비스 : 주문을 관리
- 배달 서비스 : 음식점에서 소비자에 이르기까지 주문 배달을 관리
- 음식점 서비스 : 음식점 관련 정보를 관리  
- 주방 서비스 : 주문한 음식을 준비하는 과정을 관리
- 화계 서비스 : 과금/지불을 관리  

![](./src/FTGO_MSA.png)

서비스와 API 가 분명하게 분리돼 정의된 것만 다를 뿐, 앞선 모놀리식과 정확하게 대응 된다.  
각 서비스를 **독립적으로** 개발, 테스트, 배포, 확장가능하며 개발자가 타 서비스의 API 를 우회하거나 그 내부요소에 직접 접근할 수 없어 모듈성 유지 차원에서도 적합

### 장점

#### 크고 복잡한 애플케이션을 지속적으로 전달/배포할 수 있다.  
MSA 는 다음 세가지 방법으로 지속적 전달/배포 (CD) 를 실현  
1. 테스트성 : 자동화 테스트가 필수, MSA 는 상대적으로 크기가 작아 자동화 테스트 작성이 쉽고 빠름  
2. 배포성 : 독립적으로 배포가 가능해, 굳이 다른 서비스의 개발자와 협의가 필요 없음.
3. 자율성/느슨한 결합 : 작은 팀이 여러 기술이 결합된 조직을 꾸릴 수 있음. 팀별로 하나 이상의 관련 서비스를 개발/배포 하는 업무를 담당. 다른 팀과 독립적으로 개발/배포/확장 가능  

CD 를 할 경우 비즈니스적 장점  
1. 제품이 시장에 내놓는 속도가 빨라지고, 피드백 반영속도가 빨라짐.  
2. 고객의 원하는 수준으로 확실하게 서비스 제공 가능
3. 개발자가 급한 불을 끄느라 에너지를 낭비하는 대신 제품의 가치를 전달하는 데 더 많은 시간 투자 가능  

#### 서비스가 작아 관리가 용이  

#### 독립적 배포/확장 가능

#### 결함 격리(Fault Isolation)가 잘됨

다른 서비스에서 메모리 누수가 발생해도, 해당 서비스에만 영향이 가고 다른 서비스는 계속 정상 가동 됨.  
모놀리식은 한곳이 고장나면 전체 시스템이 곤경에 빠짐  

#### 신기술 시험/도입이 쉽다.  

빼놓을 수 없는 장점으로 특정 기술 스택을 연구/도입 할 때 오랜 시간이 필요 없고, 그 서비스에 맞는 언어와 프레임워크를 자유롭게 선택 가능  
가령, 카모아에서 차량리스트는 안정성보다는 속도, 결제는 속도보다는 안정성인 경우가 될 텐데 이에 맞는 언어/DB 선택이 가능해진다.  

### 단점

#### 잘 맞는 서비스 찾기가 쉽지 않다.

MSA 에 맞게 시스템을 여러 서비스로 분해하는, 정확한 알고리즘은 없다.  
그래서 잘못 모듈화 한경우, 모놀리식과 마이크로 서비스 아키텍쳐의 단점만 존재하는 분산 모놀리스를 구축하게 됨.  

#### 분산 시스템은 복잡하다.  

분산 시스템이라는 또 다른 복잡성은 개발자가 감내해야 한다.  
서비스간 통신에서 단순 메소드 호출보다는 복잡하게 되고, 사용 불가/부분 실패와 같은 서비스를 처리할 수 있게 설계해야 함.  
또 단순 쿼리 (모듈만의 쿼리)로는 여러 서비스에 있는 데이터 조회가 어려워 API 를 조합하거나 CQRS View 로 처리가 필요  

또한, 여러 서비스가 여러 인스턴스로 띄어져 있다보니 프로덕션에서 관리해야 할 가동부가 늘어나게 됨.  
이를 해결하기 위해 여러 플랫폼들이 존재, 대표적인 예로 가장 익숙한것이 Kubernetes  

#### 여러 서비스에 걸친 공통 기능은 배포할 경우 세심하게 봐야 함

여러 서비스에 걸친 기능을 배포할 때에는 여러 개발 팀 간에 세심한 조율이 필요한 경우가 있음.  
서비스 간 디펜던시에 따라 서비스 배포 계획을 빈틈없이 수립해야 함.  

#### 도입 시기 결정의 어려움

## 소프트웨어 아키텍처의 정의와 중요성

### 소프트웨어 아키텍처의 정의

> 컴퓨터 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는데 필요한 구조의 집합
>
> <소프트웨어 아키텍처 문서화>, <바스> 등...

애플리케이션 아키텍처가 여러 파트(엘리먼트) 로의 분해와 이런 파트간의 관계라는 것.  
분해가 중요한 이유  
1. 업무와 지식을 분리. 덕분에, 전문 지식을 보유한 사람들(또는 여러 팀)이 함께 생산적으로 애플리케이션 작업을 할 수 있다.
2. 소프트웨어 엘리먼트가 어떻게 상호작용하는지 밝힌다.  

### 소프트웨어 아키텍처의 4+1 View Model

4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4 View 를 정의한다.  
각 뷰는 아키텍처의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성된다.  

![](./src/4+1_view_model.png)

* 논리 뷰 : 개발자가 작성한 소프트웨어 엘리먼트, 객체 지향 언어라면 클래스, 패키지가 해당되며 결국 상속, 연관 (association), 의존 (depends-on) 등 클래스와 패키지의 관계를 말한다.  
* 구현 뷰 (Implement/Development View) : 빌드 시스템의 결과물. 모듈(패키징된 코드)과 컴포넌트로 구성된다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 이 뷰에 포함된다.  
* 프로세스 뷰 : 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, IPC는 프로세스 간 관계를 나타낸다.  
* 배포 뷰 : 프로세스 가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹. 프로세스와 머신 사이의 관계도 이 뷰에서 기술된다.

4 View 외에도 뷰를 구동 시키는 시나리오가 있다.  
각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술.  
4 View 는 중요한 아키텍처 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시

### 아키텍쳐의 중요성

애플리케이션 요건은 크게 두 가지 종류로 나뉜다.

1. 애플리케이션이 해야 할 일을 정의한 기능요건
2. `~성` 으로 끝나는 서비스 품질 요건.

보통 유즈케이스나 사용자 스토리 포맷으로 기능요건을 기술하는데, 이 기능요건과 아키텍쳐는 거의 무관하다.  
아키텍쳐는 서비스 품질 요건을 충족시킬 수 있게 설계해야 하므로 아주 중요하다.  
확장성, 신뢰성과 같은 런타임 품질 외에도 관리성, 테스트성, 배포성처럼 개발 시점의 품질도 해당된다.  
애플리케이션 아키텍쳐를 어떻게 선택하느냐에 따라 이런 품질 요건을 얼마나 충족시킬 수 있는지 결정.  
